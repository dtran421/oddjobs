-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER LANGUAGE 'plpgsql' VOLATILE SECURITY DEFINER COST 100 AS $BODY$ BEGIN
INSERT INTO public.accounts (id, email)
VALUES (new.id, new.email);

RETURN new;

END;

$BODY$;

CREATE TABLE IF NOT EXISTS public.accounts (
    id uuid NOT NULL,
    email character varying COLLATE pg_catalog."default",
    first_name character varying COLLATE pg_catalog."default",
    last_name character varying COLLATE pg_catalog."default",
    phone_number character varying COLLATE pg_catalog."default",
    CONSTRAINT accounts_id_fkey FOREIGN KEY (id) REFERENCES auth.users (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
) TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.accounts OWNER TO supabase_admin;

ALTER TABLE IF EXISTS public.accounts ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.accounts TO anon;

GRANT ALL ON TABLE public.accounts TO authenticated;

GRANT ALL ON TABLE public.accounts TO postgres;

GRANT ALL ON TABLE public.accounts TO service_role;

GRANT ALL ON TABLE public.accounts TO supabase_admin;

COMMENT ON TABLE public.accounts IS 'user data';

CREATE POLICY "Users can insert their own profile." ON public.accounts AS PERMISSIVE FOR
INSERT TO authenticated WITH CHECK ((auth.uid() = id));

CREATE POLICY "Users can update own profile." ON public.accounts AS PERMISSIVE FOR
UPDATE TO authenticated USING ((auth.uid() = id));

DROP TABLE IF EXISTS public.users CASCADE;